const path = require('path');
const fs = require('fs-extra');
const sqlite3 = require('sqlite3').verbose();
const nunjucks = require('nunjucks');
const { minify } = require('html-minifier');

const DB_PATH = path.join(__dirname, 'weici_ext.db');
const OUTPUT_DIR = path.join(__dirname, 'docs');
const TEMPLATE_DIR = path.join(__dirname, 'templates');
const PUBLIC_DIR = path.join(__dirname, 'public');

// --- Configuration ---
const MINIFY_OPTIONS = {
    collapseWhitespace: true,
    keepClosingSlash: true, // For checking XHTML strictness manually, though this is for output
    removeComments: true,
    minifyCSS: true,
    includeAutoGeneratedTags: false
};

// --- Logging Helper ---
const Logger = {
    startTime: Date.now(),
    isCI: process.env.GITHUB_ACTIONS === 'true',
    getElapsed() {
        return ((Date.now() - this.startTime) / 1000).toFixed(1) + 's';
    },
    info(msg) {
        console.log(`[${this.getElapsed()}] INFO: ${msg}`);
    },
    warn(msg) {
        if (this.isCI) console.log(`::warning::${msg}`);
        else console.warn(`[${this.getElapsed()}] WARN: ${msg}`);
    },
    error(msg, err) {
        if (this.isCI) console.log(`::error::${msg}${err ? ' | ' + err.message : ''}`);
        else console.error(`[${this.getElapsed()}] ERROR: ${msg}`, err || '');
    }
};

async function build() {
    Logger.info('Starting build process...');

    // 1. Initialize DB
    if (!fs.existsSync(DB_PATH)) {
        Logger.error(`Database file not found at ${DB_PATH}`);
        process.exit(1);
    }
    const db = new sqlite3.Database(DB_PATH);
    Logger.info(`Connected to database at ${DB_PATH}`);

    // 2. Prepare Output Directory
    await fs.emptyDir(OUTPUT_DIR);
    await fs.ensureDir(OUTPUT_DIR);
    Logger.info(`Cleaned and prepared output directory.`);

    // 3. Configure Templating
    const env = nunjucks.configure(TEMPLATE_DIR, {
        autoescape: true,
        trimBlocks: true,
        lstripBlocks: true
    });

    // 4. Query Data
    const query = `
        SELECT 
            d.id, d.word, d.detail_json, 
            w.jump 
        FROM fb_word_detail d
        LEFT JOIN fb_word w ON d.id = w.id
    `;

    const escapeRegExp = (string) => string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    // Helper: Highlight examples
    const processExamples = (examples) => {
        if (!examples) return [];
        return examples.map(ex => {
            let en = ex.english || "";
            if (ex.highlight) {
                const highlights = ex.highlight.split(',');
                highlights.forEach(h => {
                    if (!h) return;
                    const escaped = escapeRegExp(h.trim());
                    const regex = new RegExp(`\\b${escaped}\\b`, 'gi');
                    en = en.replace(regex, (match) => `<b>${match}</b>`);
                });
            }
            return { ...ex, english: en };
        });
    }

    db.all(query, [], async (err, rows) => {
        if (err) {
            Logger.error('Database query error', err);
            process.exit(1);
        }

        Logger.info(`Fetched ${rows.length} rows.`);

        // 5. Group by Word
        const wordsMap = new Map();
        const allWordsSet = new Set();

        // Pass 1: Identify all words that will be generated
        for (const row of rows) {
            if (/^[a-zA-Z\-]+$/.test(row.word)) {
                allWordsSet.add(row.word);
            }
        }

        for (const row of rows) {
            const word = row.word;

            if (!/^[a-zA-Z\-]+$/.test(word)) {
                continue;
            }

            let data = null;
            let detailJson = row.detail_json;
            
            if (detailJson) {
                if (typeof detailJson === 'string') {
                    try {
                        data = JSON.parse(detailJson);
                    } catch(e) {}
                } else if (typeof detailJson === 'object') {
                    data = detailJson;
                }
            }

            if (!data) continue;

            // Process Data Content (Highlighting)
            if (data.gy_example) data.gy_example = processExamples(data.gy_example);
            if (data.gy_paraphrase) {
                data.gy_paraphrase.forEach(item => {
                    if (item.gy_example) item.gy_example = processExamples(item.gy_example);
                });
            }
            if (data.gy_fixed_collocation) {
                data.gy_fixed_collocation.forEach(item => {
                    if (item.gy_paraphrase) {
                        item.gy_paraphrase.forEach(para => {
                            if (para.gy_example) para.gy_example = processExamples(para.gy_example);
                        });
                    }
                });
            }
            
            if (!wordsMap.has(word)) {
                wordsMap.set(word, { 
                    entries: [], 
                    jumps: new Set(),
                    relatedIndexed: new Set(),
                    relatedUnindexed: new Set(),
                    backlinkIndexed: new Set(),
                    backlinkUnindexed: new Set()
                });
            }
            
            const wordRecord = wordsMap.get(word);
            wordRecord.entries.push(data);
            
            if (row.jump) {
                row.jump.split(',').forEach(p => {
                    const clean = p.trim();
                    if (clean) wordRecord.jumps.add(clean);
                });
            }
        }

        Logger.info(`Grouped into ${wordsMap.size} unique words.`);

        // 6. Build 4-Way Graph
        for (const [sourceWord, record] of wordsMap) {
            for (const targetWord of record.jumps) {
                if (allWordsSet.has(targetWord)) {
                    record.relatedIndexed.add(targetWord);
                    if (wordsMap.has(targetWord)) {
                        wordsMap.get(targetWord).backlinkIndexed.add(sourceWord);
                    }
                } else {
                    record.relatedUnindexed.add(targetWord);
                }
            }
        }

        // Secondary pass for backtrack unindexed backlinks (if any source is unindexed, but we don't track unindexed sources)
        // Actually, we only care about backlinks *to* our indexed words from other indexed words (as links) 
        // OR mentioned in the database generally.
        // User asked: "connected to this word's list" + "split into collected and not collected".
        // My Logic: 
        // record.relatedIndexed: Jumps from this word to other indexed words.
        // record.relatedUnindexed: Jumps from this word to words not in index.
        // record.backlinkIndexed: Jumps from other indexed words to this word.
        // record.backlinkUnindexed: (This is tricky - words not in index pointing here? We don't have detail for unindexed words to find their jumps)
        // I will stick to what's observable: Backlinks from other indexed words.
        
        Logger.info('Graph construction complete.');

        // 7. Generate Word Pages
        let generatedCount = 0;
        const sortedWords = Array.from(wordsMap.keys()).sort((a, b) => a.localeCompare(b));

        for (const word of sortedWords) {
            const record = wordsMap.get(word);
            
            const context = {
                word: word,
                entries: record.entries,
                relatedIndexed: Array.from(record.relatedIndexed).sort(),
                relatedUnindexed: Array.from(record.relatedUnindexed).sort(),
                backlinkIndexed: Array.from(record.backlinkIndexed).sort()
            };

            const html = env.render('word.html', context);
            const minifiedHtml = minify(html, MINIFY_OPTIONS);

            const filePath = path.join(OUTPUT_DIR, `${word}.html`);
            await fs.outputFile(filePath, minifiedHtml);
            generatedCount++;

            if (generatedCount % 2000 === 0) {
                Logger.info(`Generating pages: ${generatedCount} / ${sortedWords.length}...`);
            }
        }
        Logger.info(`Generated ${generatedCount} detail pages.`);

        // 8. Generate Index Page
        const groupedWords = [];
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        const indexMap = new Map();
        alphabet.forEach(char => indexMap.set(char, []));

        for (const word of sortedWords) {
            const firstChar = word.charAt(0).toUpperCase();
            if (indexMap.has(firstChar)) {
                indexMap.get(firstChar).push(word);
            }
        }

        alphabet.forEach(char => {
            const words = indexMap.get(char);
            if (words.length > 0) {
                groupedWords.push([char + char.toLowerCase(), words]);
            }
        });

        const indexHtml = env.render('index.html', {
            total_count: sortedWords.length,
            grouped_words: groupedWords,
            is_index: true
        });

        await fs.outputFile(path.join(OUTPUT_DIR, 'index.html'), minify(indexHtml, MINIFY_OPTIONS));
        Logger.info(`Generated index.html.`);

        // 9. Copy Static Assets
        await fs.copy(PUBLIC_DIR, OUTPUT_DIR);
        Logger.info('Static assets finalized.');

        Logger.info('Build completed successfully.');
        db.close();
    });
}

build().catch(err => {
    Logger.error('Global build failure', err);
    process.exit(1);
});
